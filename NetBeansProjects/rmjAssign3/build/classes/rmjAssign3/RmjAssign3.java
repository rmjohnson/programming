package rmjAssign3;

import java.io.PrintStream;
import java.util.Scanner;

/**
 * Class: Data Structures
 * Assignment: Assignment #3B
 * @author Ryan Johnson
 * Date of Last Modification: 10/17/2012
 * Description: This program takes in a series of words, entered in line by line.
 * Input is stopped once an empty line is entered. Each character is then taken
 * and then paired up with the number of times it shows up in the series of words.
 * The character and frequency are then stored in a HuffData object. The HuffData
 * is then stored in a Huffman Tree and encodings for each character are calculated
 * based off their position in the Huffman Tree.  The characters with their
 * frequencies, the characters with their encodings, the height of the Huffman
 * Tree, the number of unique characters, the shortest encoding, and the longest 
 * encoding are outputted to the console. After that, the user is able to input
 * encodings to be decoded according to the character encodings generated by
 * the Huffman Tree.
 */
public class RmjAssign3 {

    public static void main(String[] args) { //The main class
        Scanner in = new Scanner(System.in); //Initialize the scanner to get input
        //Get the input, analyze it and then store it in a HuffData array
        HuffData[] huffData = inputAnalysis(in);
        HuffmanTree huffTree = new HuffmanTree(); //Initialize the Huffman Tree
        huffTree.buildTree(huffData); //Build the Huffman Tree with the HuffData array
        //Output both the HuffData array and the Huffman Tree
        output(huffData, huffTree);
        //Get user input and decode it
        decode(in, huffTree);
    }
    
    //Method to get the input and then analyze the frequencies of the inputted characters
    public static HuffData[] inputAnalysis(Scanner in) {
        //Initialize the HuffData array to the biggest size it can possibly be
        //because there should only be one letter per HuffData and there are
        //only 26 letters in the English alphabet
        HuffData[] huffData = new HuffData[26];
        int huffTop = 0; //Start the top of the HuffData array at 0, the first index
        //Intialize the total input to an empty string so the loop doesn't try
        //to concanate on a null string
        String input = ""; 
        //Get the first input line and store it in a temporary string
        String tmpInput = in.nextLine(); 
        //Intialize the char array to store all the letters in the input
        char[] charArray; 
        int flag = 0; //Initialize the flag to 0, the default state
        //Keep getting input until the user enters a blank line
        while (!tmpInput.equals("")) { 
            input += tmpInput; //Add the Scanner input to the input string
            tmpInput = in.nextLine(); //Get the next line and store it in tmpInput
        }
        //After all the input is collected, convert the string to a char array
        charArray = input.toCharArray();
        for (char c : charArray) { //Loop through every char in the char array
            flag = 0; //Reset the flag to 0, the default state
            //Loop through what is in the HuffData array so far
            for (int i = 0; i < huffTop; i++) { 
                //If the character is already in the HuffData array
                if (c == huffData[i].symbol) { 
                    flag = 1; //Set the flag to 1, meaning we found a match
                    //Add one to the weight (frequency) in the current HuffData
                    //because we found another one of the character in the input
                    huffData[i].weight = huffData[i].weight + 1;
                }
            }
            //If the flag is still 0, meaning the character wasn't already in
            //the HuffData array
            if (flag == 0) {
                //Make a new HuffData object with the character and a weight
                //of 1 and stick it at the top of the HuffData array then
                //increment the huffTop variable
                huffData[huffTop++] = new HuffData(1, c);
            }
        }
        //Create a temporary HuffData array, you'll see why in a second
        HuffData[] tmpHuffData = new HuffData[huffTop];
        //Copy just the part of the HuffData array with characters over to the
        //temporray HuffData array, removing all null values
        System.arraycopy(huffData, 0, tmpHuffData, 0, huffTop);
        //Return the temporary HuffData array so the length of it is exactly
        //how many HuffData objects it holds
        return tmpHuffData;
    }
    
    //Method to output everything at the end
    public static void output(HuffData[] huffdata, HuffmanTree tree) {
        //Output a message letting the user know the analysis is done
        System.out.println("Input analysis complete.");
        //Loop through the passed in HuffData array and output the symbol and weight
        for (HuffData huffData : huffdata) {
            System.out.println(huffData.symbol + " " + huffData.weight);
        }
        //Output various attributes about the tree
        System.out.println("Binary tree height: " + tree.getHeight());
        System.out.println("Unique characters in the tree: " + huffdata.length);
        tree.printCode(new PrintStream(System.out), "", tree.getHuffTree());
        System.out.println("Shortest encoding: " + tree.getShortestEncoding());
        System.out.println("Longest encoding: " + tree.getLongestEncoding());

    }
     
    public static void decode(Scanner in, HuffmanTree tree) {
        //Prompt the user for input
        System.out.println("Enter a string to be decoded: ");
        //Get the input and store it to an input string
        String input = in.nextLine();
        while(!input.equals("quit")) { //Loop until the user says "quit"
            //Output the decoding of the user input
            System.out.println(input + " = " + tree.decode(input));
            //Get the next input to be decoded
            input = in.nextLine();
        }
        //Say goodbye once the user types "quit"
        System.out.println("bye");
    }
}
